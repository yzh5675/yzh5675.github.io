<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue语法及入门基础</title>
      <link href="/posts/3fde.html"/>
      <url>/posts/3fde.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="一、什么是Vue？"><a href="#一、什么是Vue？" class="headerlink" title="一、什么是Vue？"></a>一、什么是Vue？</h2><p>动态构建用户界面的渐进式 JavaScript 框架。</p><h2 id="二、模板语法"><a href="#二、模板语法" class="headerlink" title="二、模板语法"></a>二、模板语法</h2><h3 id="1-插值语法"><a href="#1-插值语法" class="headerlink" title="1. 插值语法"></a>1. 插值语法</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">// 用于解析标签体内容&lt;h1&gt;{{xxx}}&lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-指令语法"><a href="#2-指令语法" class="headerlink" title="2. 指令语法"></a>2. 指令语法</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">// 解析标签属性、解析标签体内容、绑定事件&lt;a v-bind:href="xxx"&gt;百度&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、数据绑定"><a href="#三、数据绑定" class="headerlink" title="三、数据绑定"></a>三、数据绑定</h2><h3 id="1-单向数据绑定"><a href="#1-单向数据绑定" class="headerlink" title="1.单向数据绑定"></a>1.单向数据绑定</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 语法 --&gt;&lt;!-- 或简写为 :href --&gt;&lt;p v-bind:href ="xxx"&gt;&lt;/p&gt;&lt;!-- 特点：数据只能从 data 流向页面 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-双向数据绑定"><a href="#2-双向数据绑定" class="headerlink" title="2.双向数据绑定"></a>2.双向数据绑定</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 语法 --&gt;&lt;!-- 或简写为  v-model="xxx" --&gt;&lt;p v-model:value ="xxx"&gt;&lt;/p&gt;&lt;!-- 数据不仅能从 data 流向页面，还能从页面流向 data --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、MVVM-模型"><a href="#四、MVVM-模型" class="headerlink" title="四、MVVM 模型"></a>四、MVVM 模型</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            M：模型(Model) ：对应 data 中的数据</p><p>​            V：视图(View) ：模板</p><p>​            VM：视图模型(ViewModel) ： Vue 实例对象</p><p><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211021192325645.png" alt="MVVM模型"></p><p>解释：</p><p><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211021192350130.png" alt="模型解释"></p><h2 id="五、事件处理和事件、按键修饰符"><a href="#五、事件处理和事件、按键修饰符" class="headerlink" title="五、事件处理和事件、按键修饰符"></a>五、事件处理和事件、按键修饰符</h2><h3 id="1-事件处理"><a href="#1-事件处理" class="headerlink" title="1. 事件处理"></a>1. 事件处理</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 语法 --&gt;&lt;p v-on:事件名="函数名(参数或无参)"&gt;&lt;/p&gt;&lt;!-- 简略写法 --&gt;&lt;p @事件名="函数名(参数或无参)"&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-事件修饰符"><a href="#2-事件修饰符" class="headerlink" title="2. 事件修饰符"></a>2. 事件修饰符</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- prevent阻止事件的默认行为 --&gt;&lt;a href="https://www.baidu.com" @click.prevent="函数名()"&gt;点我到百度&lt;/a&gt;&lt;!-- 阻止事件冒泡 --&gt;&lt;div class="apps" @click="showInfo()"&gt;    &lt;!-- stop：阻止事件冒泡 --&gt;    &lt;!-- 链式写法 --&gt;    &lt;button type="button" @click.stop.prevent="函数名()"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;!-- once：事件只能触发一次 --&gt;&lt;button type="button" @click.once="函数名()"&gt;点我&lt;/button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-按键修饰符"><a href="#3-按键修饰符" class="headerlink" title="3. 按键修饰符"></a>3. 按键修饰符</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 指定按键，键码或者键名都行,键的别名也行 --&gt;&lt;!-- Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态事件通常与函数结合使用，函数不会在事件发生前被执行 --&gt;&lt;input type="text" name="" id="" value="" @keydown.键名="showInfo($event)" placeholder="按下回车提示输入....." /&gt;&lt;!-- 自定义键名 --&gt;&lt;!-- 声明一个键别名，键码为13 --&gt;Vue.config.keyCodes.huiche = 13;new Vue({......});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、计算属性"><a href="#六、计算属性" class="headerlink" title="六、计算属性"></a>六、计算属性</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            <strong>在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以</strong>，要显示的数据不存在，要通过计算得来，计算属性其实和函数没什么区别</p><h3 id="2-声明和使用计算属性"><a href="#2-声明和使用计算属性" class="headerlink" title="2. 声明和使用计算属性"></a>2. 声明和使用计算属性</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    new Vue({        el : "#app",        // 每个计算属性中默认有get和set方法，可以写也可以不写        computed:{// 计算属性            fullName : {                get(){// 当使用fullName这个计算属性时就会调用此get方法                    console.log("get方法被调用了!");                    return this.fistName +"-"+ this.lastName;                },                set(value){// fullName这个计算属性发生发生改变时就会调用此set方法                    console.log("set方法", value);                }            }       },    });    // 使用计算属性：{{计算属性名}}可以触发get方法    // v-model="计算属性名" 可以触发set方法&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-计算属性缓存和函数（方法）的区别"><a href="#3-计算属性缓存和函数（方法）的区别" class="headerlink" title="3. 计算属性缓存和函数（方法）的区别"></a>3. 计算属性缓存和函数（方法）的区别</h3><p>​            两者最主要的区别：computed 是<strong>可以缓存的</strong>，methods <strong>不能缓存</strong>；<strong>只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，就不会多次执行。</strong></p><h3 id="4-计算属性通过闭包方式传参"><a href="#4-计算属性通过闭包方式传参" class="headerlink" title="4. 计算属性通过闭包方式传参"></a>4. 计算属性通过闭包方式传参</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    computed: {        closure () {            return function (a, b, c) {                .......                return data;            }        }    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、监听（侦听）属性"><a href="#七、监听（侦听）属性" class="headerlink" title="七、监听（侦听）属性"></a>七、监听（侦听）属性</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            顾名思义，监听某个属性的变化并对其进行一些操作，Watch中可以执行任何逻辑，如函数节流、Ajax异步获取数据，甚至操作 DOM（不建议）</p><h3 id="2-声明及用法"><a href="#2-声明及用法" class="headerlink" title="2. 声明及用法"></a>2. 声明及用法</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- HTML --&gt;&lt;div id="app"&gt;    姓：&lt;input type="text" name="" id="" value="" v-model="fistName" /&gt;&lt;br /&gt;    名：&lt;input type="text" name="" id="" value="" v-model="lastName" /&gt;&lt;br /&gt;    &lt;p&gt;全名：{{fistName}} - {{lastName}} &lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    new Vue({        el : '#app',        data : {            fistName : "阿",            lastName : "龟"        },        watch:{// 监视属性，当fistName或lastName发生改变时就会触发监视属性            fistName : {                deep : true,//  deep：需要监听的数据的深度，一般用来监听对象中某个属性的变化,数组字符串一般不需要                // 在选项参数中指定 immediate: true将立即以表达式的当前值触发回调,                immediate : false,// 初始化，调用一次handler                // 第一个参数为新值，第二个参数为旧值，如果调用的旧值会发生无限更新值的情况                handler(newValue, oldValue){// handle：watch中需要具体执行的方法                    console.log(oldValue, newValue);                    this.fistName = newValue;                }            },            lastName : {                handler(newValue, oldValue){                    console.log(oldValue, newValue);                    this.lastName = newValue;                }            }        }    });&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、计算属性和监视属性的总结"><a href="#八、计算属性和监视属性的总结" class="headerlink" title="八、计算属性和监视属性的总结"></a>八、计算属性和监视属性的总结</h2><h3 id="1-计算属性和监视属性的区别"><a href="#1-计算属性和监视属性的区别" class="headerlink" title="1.计算属性和监视属性的区别"></a>1.计算属性和监视属性的区别</h3><p>​            ① computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</p><p>​            ② watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作</p><p>​            主要区别：</p><p>​                <strong>计算属性不能执行异步任务，计算属性必须同步执行</strong>，而监视属性可以实现异步</p><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>​            ① 计算属性能做的监视属性也能做，反之则不行</p><p>​            ② 尽量使用计算属性来替代监视属性</p><h2 id="九、class-与-style-绑定"><a href="#九、class-与-style-绑定" class="headerlink" title="九、class 与 style 绑定"></a>九、class 与 style 绑定</h2><h3 id="1-概念：字面意思"><a href="#1-概念：字面意思" class="headerlink" title="1.概念：字面意思"></a>1.概念：字面意思</h3><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;class 与 style 绑定&lt;/title&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt;&lt;style&gt;.c1{color: red;}.c2{font-size: 30px;}.c3{font-weight: 600;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;ul&gt;&lt;li :class="cl1"&gt;aguiagu&lt;/li&gt;&lt;li :class="['c1', 'c2', 'c3']"&gt;fas&lt;/li&gt;&lt;li :style="{color: colors, 'font-weight': fonts}"&gt;erwe&lt;/li&gt;&lt;li :style="styleList"&gt;fsa&lt;/li&gt;&lt;li :class="{c1:t}"&gt;gsdfg&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;new Vue({el : "#app",data : {cl1 : 'c1',cl2 : 'c2',cl3 : 'c3',t : true,f : false,colors : 'blue',fonts : 800,styleList : {// 属性集合color : 'green',fontWeight : 900}}})&lt;/script&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、条件渲染"><a href="#十、条件渲染" class="headerlink" title="十、条件渲染"></a>十、条件渲染</h2><h3 id="1-v-if和v-show"><a href="#1-v-if和v-show" class="headerlink" title="1. v-if和v-show"></a>1. v-if和v-show</h3><p>​        ① 概念：都相当于相当于Java中的if-else</p><p>​        ② 原理：</p><p>​                v-show指令：元素始终被渲染到HTML，它只是简单的伪元素设置css的style属性，当不满足条件的元素被设置style=“display：none”的样，是通过修改元素的的CSS属性(display)来决定实现显示还是隐藏</p><p>​                v-if指令：满足条件是会渲染到html中，不满足条件时是不会渲染到html中的，是通过操纵dom元素来进行切换显示</p><p>​        ③ 使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div id="app"&gt;    &lt;p v-if="ok"&gt;表白成功&lt;/p&gt;    &lt;p v-else&gt;表白失败&lt;/p&gt;    &lt;hr /&gt;    &lt;p v-show="ok"&gt;求婚成功&lt;/p&gt;    &lt;p v-show="!ok"&gt;求婚失败&lt;/p&gt;    &lt;button type="button" @click="ok = !ok"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    new Vue({        el:'#app',        data:{            ok: true        }    })&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-总结-1"><a href="#2-总结-1" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>​            如果频繁切换建议使用v-show</p><h2 id="十一、列表渲染"><a href="#十一、列表渲染" class="headerlink" title="十一、列表渲染"></a>十一、列表渲染</h2><h3 id="1-v-for"><a href="#1-v-for" class="headerlink" title="1. v-for"></a>1. v-for</h3><p>​            ① 概念：相当于Java中的for循环</p><p>​            ② 使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;列表渲染&lt;/title&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;!-- 数组遍历 --&gt;&lt;h1&gt;遍历人员&lt;/h1&gt;&lt;table border="" cellspacing="" cellpadding=""&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;age&lt;/th&gt;&lt;/tr&gt;&lt;tr v-for="(p, index) of persons" :key="index"&gt;&lt;td&gt;{{p.id}}&lt;/td&gt;&lt;td&gt;{{p.name}}&lt;/td&gt;&lt;td&gt;{{p.age}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- 遍历对象 --&gt;&lt;h1&gt;遍历对象&lt;/h1&gt;&lt;table border="" cellspacing="" cellpadding=""&gt;&lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;th&gt;color&lt;/th&gt;&lt;/tr&gt;&lt;tr v-for="(c, key, i) in cars" :key="key"&gt;&lt;!-- i是索引 --&gt;&lt;td&gt;{{c}}&lt;/td&gt;&lt;td&gt;{{c}}&lt;/td&gt;&lt;td&gt;{{c}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- 遍历字符串 --&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;new Vue({el : "#app",data : {persons : [{id : "001", name : "Tom", age : 20},{id : "002", name : "Jack", age : 20},{id : "003", name : "Lisa", age : 20},{id : "004", name : "Dawei", age : 20},{id : "005", name : "agui", age : 20}],cars : {name : "比亚迪",price : 380000,color : "red"}},methods:{}})&lt;/script&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-数据过滤和排序"><a href="#2-数据过滤和排序" class="headerlink" title="2. 数据过滤和排序"></a>2. 数据过滤和排序</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    new Vue({        el : "#app",        data : {            persons : [                {id : "001", name : "Tom", age : 20},                {id : "002", name : "Jack", age : 20},                {id : "003", name : "Lisa", age : 20},                {id : "004", name : "Dawei", age : 20},                {id : "005", name : "agui", age : 20}            ],            keyWorld : ""        },        computed : {            fn(v){                // 使用filter过滤函数实现数据过滤                return this.persons.filter (k =&gt; {// k代表this                    return k.name.indexOf(this.keyWorld) !== -1;                });                                // 排序                if(orderType){                    persons.sort(function (a,b) {                        if(orderType===1){                            return a.age-b.age;                        }else{                            return b.age-a.age;                        }                    });                }            }        }    })&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十二、自定义指令"><a href="#十二、自定义指令" class="headerlink" title="十二、自定义指令"></a>十二、自定义指令</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>​            ① 一个指令对象的定义可以使用如下的几种钩子函数：</p><p>​                    <code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</p><p>​                    <code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</p><p>​                    <code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有</p><p>​                    <code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用</p><p>​                    <code>unbind</code>：只调用一次，指令与元素解绑时调用</p><h3 id="2-定义自定义指令"><a href="#2-定义自定义指令" class="headerlink" title="2.定义自定义指令"></a>2.定义自定义指令</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    // 全局自定义指令，el指：指令所在的标签dom    Vue.directive('指令名', function(el, bind){        el.innerText = bind.value*100;    });   new Vue({        // 自定义局部指令        directives : {        big(el, bind){element.innerText = bind.value*100;}}    });&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十二、页面优化"><a href="#十二、页面优化" class="headerlink" title="十二、页面优化"></a>十二、页面优化</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- v-once所在节点的视为静态属性，只渲染一次，常用于优化页面 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-once</span><span class="token punctuation">&gt;</span></span>n的值为：{{n}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑，常用于页面优化 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-pre</span><span class="token punctuation">&gt;</span></span>{{n}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>n的值为：{{n}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>n++<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点我n+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十三、Vue的生命周期"><a href="#十三、Vue的生命周期" class="headerlink" title="十三、Vue的生命周期"></a>十三、Vue的生命周期</h2><ul><li><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211022164544216.png" alt="Vue生命周期"></li></ul><h1 id="Vue-cli：vue脚手架"><a href="#Vue-cli：vue脚手架" class="headerlink" title="Vue-cli：vue脚手架"></a>Vue-cli：vue脚手架</h1><h2 id="一、Vue组件化编程"><a href="#一、Vue组件化编程" class="headerlink" title="一、Vue组件化编程"></a>一、Vue组件化编程</h2><h3 id="1-模块与组件"><a href="#1-模块与组件" class="headerlink" title="1. 模块与组件"></a>1. 模块与组件</h3><p>​            1）模块</p><p>​                ① 理解: 向外提供特定功能的 JS 程序, 一般就是一个 JS 文件</p><p>​                ② 为什么？ JS 文件很多很复杂</p><p>​                ③ 作用：复用 JS, 简化 JS 的编写, 提高 JS 运行效率</p><p>​            2）组件</p><p>​                ① 理解：用来实现局部(特定)功能效果的代码集合(html/css/js/image…..)</p><p>​                ③ 为什么：一个界面的功能很复杂</p><p>​                ② 作用：复用编码, 简化项目编码, 提高运行效率</p><h3 id="2-模块化与组件化"><a href="#2-模块化与组件化" class="headerlink" title="2. 模块化与组件化"></a>2. 模块化与组件化</h3><p>​            1）模块化</p><p>​                当应用中的 JS 都以模块来编写的, 那这个应用就是一个模块化的应用</p><p>​            2）组件化</p><p>​                当应用中的功能都是多组件的方式来编写的， 那这个应用就是一个组件化的应用</p><h2 id="二、vue脚手架"><a href="#二、vue脚手架" class="headerlink" title="二、vue脚手架"></a>二、vue脚手架</h2><h3 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果安装了旧版的vue/cli，先卸载</span><span class="token comment"># 方法一</span><span class="token function">npm</span> uninstall vue-cli -g<span class="token comment"># 方法二</span><span class="token function">yarn</span> global remove vue-cli<span class="token comment"># 安装</span><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli<span class="token comment"># 检查是否安装完成 ---&gt;  查看vue/cli版本</span>vue --version<span class="token comment"># 升级vue/cli版本（直接到最新版本）</span><span class="token function">npm</span> update -g @vue/cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-使用vue-cli创建vue项目"><a href="#3-使用vue-cli创建vue项目" class="headerlink" title="3. 使用vue/cli创建vue项目"></a>3. 使用vue/cli创建vue项目</h3><p>​            1）cmd方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 第一步：切换到你要创建项目的目录，然后使用命令创建项目</span>vue create helloworld<span class="token comment"># 第二步：选择 vue2 或者 vue3 回车，会在当前目录下创建名为 helloworld 的项目（建议vue2）</span><span class="token comment"># 第三步：进入项目目录</span><span class="token comment"># 第四步：运行项目</span><span class="token function">npm</span> run serve<span class="token comment"># 第五步：浏览器运行初始化项目,vue默认访问端口8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            2）图形化界面创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 输入回车后会自动打开vue的图形化界面</span>vue ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​            3）如果出现下载缓慢解决方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 配置淘宝镜像</span><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​            4）如果Vue 脚手架隐藏了所有 webpack 相关的配置解决方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看具体的 webpack 配置</span>vue inspect <span class="token operator">&gt;</span> output.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-模板项目的结构"><a href="#4-模板项目的结构" class="headerlink" title="4. 模板项目的结构"></a>4. 模板项目的结构</h3><p><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211025181237348.png" alt="项目结构"></p><h2 id="三、ref-与-props"><a href="#三、ref-与-props" class="headerlink" title="三、ref 与 props"></a>三、ref 与 props</h2><h3 id="1-ref"><a href="#1-ref" class="headerlink" title="1.ref"></a>1.ref</h3><p>​            1）作用：用于给节点打标识</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!-- 定义ref --&gt;&lt;h2ref="tilte" @click="showInfo()"&gt;阿龟&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: 'App',    methods:{showInfo(){// 读取ref，取出标记的内容，获取整个被标记的标签console.log(this.$refs.tilte);}        }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-props"><a href="#2-props" class="headerlink" title="2. props"></a>2. props</h3><pre><code>         1）作用：用于父组件给子组件传递数据（父子组件间通信）</code></pre><p>​             2）使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 父组件 --&gt;&lt;template&gt;&lt;div&gt;        &lt;!-- 数据传输 --&gt;        &lt;HelloWorld :name="name" :age="age" :adr="adr" :fn="fn"&gt;&lt;/HelloWorld&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!-- 子组件 --&gt;&lt;script&gt;export default {// 第一种定义属性方式，常用props:['age', 'adr'],// 第二种方式定义属性，常用props:{ age : Number, adr : String, name: String,fn: Function},// 第三种定义属性的方式props:{age : {type:Number, required:true, default:18},adr : {type:String, required:true, default:'湖南长沙'},name: {type:String, required:true, default:'阿龟'},fn: {type:Function, required:true, default:function fn(){console.log(465123);}}}}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、混入"><a href="#四、混入" class="headerlink" title="四、混入"></a>四、混入</h2><h3 id="1-概念-4"><a href="#1-概念-4" class="headerlink" title="1.概念"></a>1.概念</h3><p>​            将组件的选项中的一部分分离出去，单独管理</p><h3 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>​            1）全局混入（不推荐 ）</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：创建mixin.js文件，文件名可以随便取 --&gt;export const hello ={methods : {hello(){console.log("混入");}}}&lt;!-- 第二步：在main.js中引入混入的js文件 --&gt;import {hello} from './mixin.js'&lt;!-- 第三步：在main.js中使用混入 --&gt;Vue.mixin(hello)&lt;!-- 第四步：使用混入 --&gt;&lt;template&gt;&lt;div&gt;&lt;button type="button" @click="hello"&gt;混入&lt;/button&gt;&lt;!-- 混入调用的函数名 --&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {mixins:['hello'],// 混入    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        2）局部混入</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：创建mixin.js文件，文件名可以随便取 --&gt;export const hello ={methods : {hello(){console.log("混入");}}}&lt;!-- 使用混入 --&gt;&lt;template&gt;&lt;div&gt;&lt;button type="button" @click="hello"&gt;混入&lt;/button&gt;&lt;!-- 混入调用的函数名 --&gt;&lt;/div&gt;&lt;/template&gt;&lt;!-- 在需要的组件里引入minxin.js文件 --&gt;&lt;script&gt;// 引入minxing.js文件        // 使用的话和全局差不多，就是引入不同     export default {mixins:['hello'],// 混入    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、插件"><a href="#五、插件" class="headerlink" title="五、插件"></a>五、插件</h2><h3 id="1-概念-5"><a href="#1-概念-5" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            插件通常用来为 Vue 添加全局功能</p><h3 id="2-使用-2"><a href="#2-使用-2" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：创建并编写plug.js文件，文件名随便取 --&gt;export default{install (Vue, x, y, z){console.log(x, y, z);// 定义全局指令// 全局自定义指令Vue.directive('big', function(ele, bind){ele.innerText = bind.value*100;});// 定义混入Vue.mixin({data(){return{}},methods:{}});// 定义全局函数Vue.prototype.hi = ()=&gt;{alert("hello");}}}&lt;!-- 第二步：在main.js中引入并使用插件插件 --&gt;// 引入插件import plugin from './plugin.js'// 使用插件Vue.use(plugin);&lt;!-- 使用插件 --&gt;&lt;div&gt;    &lt;!-- 插件调用的函数名 --&gt;    &lt;button type="button" @click="hi"&gt;插件&lt;/button&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、自定义事件"><a href="#六、自定义事件" class="headerlink" title="六、自定义事件"></a>六、自定义事件</h2><h3 id="1-概念-6"><a href="#1-概念-6" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            自己定义一个事件，使其完成预想的操作</p><h3 id="2-使用-3"><a href="#2-使用-3" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    export default {        // 第一步        mounted(){            // $on：创建自定义事件$once：只能触发一次的自定义事件                        // 通过ref标记一个节点来进行创建自定义事件this.$refs.school.$on('diy', data);// data可以是任何数据类型包括函数                        // 不使用ref创建自定义事件            this.$on('diy', data);// data可以是任何数据类型包括函数        }            }&lt;/script&gt;&lt;!-- 第二步：在组件中使用自定义事件 --&gt;&lt;template&gt;&lt;div&gt;&lt;button type="button" @click="diyEvent"&gt;使用自定义事件&lt;/button&gt;&lt;button type="button" @click="unbind"&gt;解绑自定义事件&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{data() {return{name : 'agui',adress : '湖南长沙'}},methods : {diyEvent(){// 使用自定义事件 ---  $emitthis.$emit('diy', this.name);},unbind(){// 解绑事件this.$off('diy');}}}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-全局事件总线"><a href="#3-全局事件总线" class="headerlink" title="3.全局事件总线"></a>3.全局事件总线</h3><p>​            1）概念：一种组件间的通信方式，适用于任意组件间通信</p><p>​            2）使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：在全局事件总线上定义一个函数hello --&gt;&lt;template&gt;&lt;div&gt;&lt;h2&gt;{{name}}&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{data(){return{name : "阿君"}}，mounted(){// 在全局事件总线上定义一个函数hellothis.$bus.$on("hello", (data) =&gt; {this.stuName = data;});}}&lt;/script&gt;&lt;!-- 第二步：在其他组件中使用全局事件总线 --&gt;&lt;script&gt;export default{    methods : {            sendBusValue(){// 使用事件总线this.$bus.$emit('hello', this.name);}        }    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><p>​            子向父传递数据、销毁组件代码见 <strong>customassembly项目</strong></p><h2 id="七、消息订阅及发布"><a href="#七、消息订阅及发布" class="headerlink" title="七、消息订阅及发布"></a>七、消息订阅及发布</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>​            1）这种方式的思想与全局事件总线很相似</p><p>​            2）它包含以下操作: </p><p>​                ① 订阅消息 –对应绑定事件监听</p><p>​                ② 发布消息 –分发事件</p><p>​                ③ 取消消息订阅 –解绑事件监听</p><p>​            3）实现需要引入一个消息订阅与发布的第三方实现库: PubSubJS</p><h3 id="2-使用-4"><a href="#2-使用-4" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 第一步：在对应的项目下安装PubSubJS</span><span class="token function">npm</span> <span class="token function">install</span> -S pubsub-js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;// 第二步：引入PubSubJS    import PubSub from 'pubsub-js'       // 发布订阅消息，发布之后会自动回调接收订阅的函数PubSub.publish("msgName", data);        // 接收订阅消息的回调函数    PubSub.subscribe("msgName", functon(msgName, data){ });        // 当用完消息就一定要取消消息的订阅   PubSub.unsubscribe(发布事件唯一ID);&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、Vue中的Ajax"><a href="#八、Vue中的Ajax" class="headerlink" title="八、Vue中的Ajax"></a>八、Vue中的Ajax</h2><h3 id="1-解决开发环境-Ajax-跨域问题"><a href="#1-解决开发环境-Ajax-跨域问题" class="headerlink" title="1. 解决开发环境 Ajax 跨域问题"></a>1. 解决开发环境 Ajax 跨域问题</h3><p>​            1）cors配置响应头</p><p>​                缺点：麻烦后端人员，不安全，任何人都能访问</p><p>​            2）JSONP jQuery</p><p>​            3）使用代理服务器</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;// 在项目跟目录下创建vue.config.js文件    module.exports = {pages: {index: {// 入口entry: 'src/main.js',},},lintOnSave : false,// 关闭语法检查// 开启代理服务器(一)  /**devServer: {proxy : '要代理的地址'}*/            // 开启代理服务器(二)    devServer: {proxy : {// 根据访问api的名字进行代理            '/admin' : {                target : '要代理的地址',                pathRewrite : {                    '^/admin' : ''                },                ws : true,// 是否支持websocket                changeOrigin : true// 是否控制请求头中host值            }        }} }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-VUE-项目中常用的二个-Ajax-库-—–-axios"><a href="#2-VUE-项目中常用的二个-Ajax-库-—–-axios" class="headerlink" title="2.VUE 项目中常用的二个 Ajax 库 —– axios"></a>2.VUE 项目中常用的二个 Ajax 库 —– axios</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 把axios安装在项目下</span><span class="token function">npm</span> i –save axios<span class="token comment"># 安装qs，qs作业将参数序列化成url 如；uid=cs11&amp;pwd=abc&amp;username=cs11</span><span class="token function">npm</span> <span class="token function">install</span> qs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;// 在需要的组件中导入axios    import axios from 'axios'        // 使用    export default {        methods: {            methodName01(){                // data可以不写，data：传的参数（只适用于get，post方式不适用）                axios                .get("/api/emp", data)                .then(resp =&gt; {                    // 回调函数                })                .catch(erro =&gt; {                    // 错误处理                });            },            methodName02(){// post方式                // data可以不写，data：传的参数（只适用于get，post方式不适用）                axios                .put("/api/emp", qs.stringify(data))                .then(resp =&gt; {                    // 回调函数                })                .catch(erro =&gt; {                    // 错误处理                });            }                    }    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="九、slot-插槽"><a href="#九、slot-插槽" class="headerlink" title="九、slot 插槽"></a>九、slot 插槽</h2><h3 id="1-插槽内可以是任意内容"><a href="#1-插槽内可以是任意内容" class="headerlink" title="1. 插槽内可以是任意内容"></a>1. 插槽内可以是任意内容</h3><p>​            父组件向子组件传递带数据的标签，当一个组件有不确定的结构时, 就需要使用 slot 技术，注意：插槽内容是在父组件中编译后, 再传递给子组件的</p><h3 id="2-插槽的分类及使用"><a href="#2-插槽的分类及使用" class="headerlink" title="2.插槽的分类及使用"></a>2.插槽的分类及使用</h3><p>​            1）默认插槽</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;div&gt;        &lt;!-- 定义一个插槽 --&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template&gt;&lt;!-- 使用 --&gt;&lt;组件名&gt;    插槽内容    &lt;/组件名&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        2）命名插槽</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;div&gt;        &lt;!-- 定义一个命名插槽 --&gt;        &lt;slot name="game"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template&gt;&lt;!-- 使用 --&gt;&lt;组件名&gt;        插槽内容...        &lt;a slot="game" href="#"&gt;更多游戏&lt;/a&gt;    &lt;/组件名&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        3）作用域插槽</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;div&gt;       &lt;!-- 作用域插槽 --&gt;&lt;slot :games="games"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template&gt;&lt;!-- 使用 --&gt;&lt;组件名&gt;        &lt;!-- 作用域插槽scope --&gt;        &lt;template scope="game"&gt;            &lt;ul&gt;                &lt;li&gt;dfasd&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;    &lt;/组件名&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、Vuex"><a href="#十、Vuex" class="headerlink" title="十、Vuex"></a>十、Vuex</h2><h3 id="1-概念-7"><a href="#1-概念-7" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​                专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 VUE 应用中多 个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且 适用于任意组件间通信。</p><h3 id="2-Vuex的使用场景"><a href="#2-Vuex的使用场景" class="headerlink" title="2. Vuex的使用场景"></a>2. Vuex的使用场景</h3><p>​                1）多个组件依赖于同一状态</p><p>​                2）来自不同组件的行为需要变更同一状态</p><h3 id="3-项目下安装Vuex"><a href="#3-项目下安装Vuex" class="headerlink" title="3. 项目下安装Vuex"></a>3. 项目下安装Vuex</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">npm</span> i –save vuex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-核心概念和API"><a href="#4-核心概念和API" class="headerlink" title="4. 核心概念和API"></a>4. 核心概念和API</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解与反射详解</title>
      <link href="/posts/dxi2.html"/>
      <url>/posts/dxi2.html</url>
      
        <content type="html"><![CDATA[<h1 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h1><h2 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h2><h5 id="一、注解的概述-Annotation"><a href="#一、注解的概述-Annotation" class="headerlink" title="一、注解的概述(Annotation)"></a>一、注解的概述(Annotation)</h5><p>​    1.注解：代码里的特殊标记，这些标记可以再编译、类加载、运行时读取，并执行相应的处理</p><h5 id="二、三大基本注解"><a href="#二、三大基本注解" class="headerlink" title="二、三大基本注解"></a>二、三大基本注解</h5><p>​    @Override: 限定重写父类方法, 该注解只能用于方法。<br>​    @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。<br>​    @SuppressWarnings: 抑制编译器警告</p><h5 id="三、自定义注解"><a href="#三、自定义注解" class="headerlink" title="三、自定义注解"></a>三、自定义注解</h5><p>1.加@interface关键字</p><p>2.① 元注解：描述注解的注解<br>   ② 元注解有哪些？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Inherited</span><span class="token comment">// 使该注解具有继承性，自动继承</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token comment">// 在运行时保留该注解</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span>PARAMETER<span class="token punctuation">,</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span>CONSTRUCTOR<span class="token punctuation">,</span>  <span class="token class-name">ElementType</span><span class="token punctuation">.</span>LOCAL_VARIABLE<span class="token punctuation">,</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE_PARAMETER<span class="token punctuation">,</span>   <span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 用于修饰哪些程序元素</span><span class="token annotation punctuation">@Documented</span><span class="token comment">// 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    ③ 自定义注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ 元注解<span class="token comment">// 表示用在什么地方</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> 注解名<span class="token punctuation">{</span><span class="token comment">// 注解执行的代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="四、为什么使用注解"><a href="#四、为什么使用注解" class="headerlink" title="四、为什么使用注解"></a>四、为什么使用注解</h5><p>​    简化开发步骤，去除繁冗的xml代码</p><h5 id="五、优点和缺点"><a href="#五、优点和缺点" class="headerlink" title="五、优点和缺点"></a>五、优点和缺点</h5><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>​        ① 保存在 class 文件中，降低维护成本。<br>　　        ② 无需工具支持，无需解析。<br>　　        ③ 编译期即可验证正确性，查错变得容易。<br>　　        ④ 提升开发效率。 </p><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>​        ① 若要对配置项进行修改，不得不修改 Java 文件，重新编译打包应用。<br>　　② 配置项编码在 Java 文件中，可扩展性差。    </p><h2 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h2><h5 id="一、Class类"><a href="#一、Class类" class="headerlink" title="一、Class类"></a>一、Class类</h5><p>​    1、概述：Class本身也是一个类，Class对象只能有系统建立对象，一个类在 JVM 中只会有一个 Class 实例 ，一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件<br>​    2、实例化Class类对象<br>​        ① 若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高<br>​             </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>sys<span class="token operator">:</span>clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        ② 已知某个类的实例，调用该实例的 getClass()方法获取 Class 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Class</span> clazz <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sys<span class="token operator">:</span>clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        ③ 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName()获取，可能抛出 ClassNotFoundException</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"类路径"</span><span class="token punctuation">;</span><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token class-name">ClassName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sys<span class="token operator">:</span>clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="二、反射-1"><a href="#二、反射-1" class="headerlink" title="二、反射"></a>二、反射</h5><p>​    1、概述：程序在运行时能够获取自身的信息<br>​    2、作用：<br>​        ① 可以通过类的反射查看类的信息<br>​        ② 使用反射生成并操作对象，调用其方法、属性<br>​               生成对象：<br>​            </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"类路径"</span><span class="token punctuation">;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> c1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        调用属性和方法<br>​            1.调用指定的方法通过反射，调用类中的方法，通过 Method 类完成<br>​            2.调用指定属性在反射机制中，可以直接通过 Field 类操作类中的属性，通过 Field 类提供的set()和 get()方法就可以完成设置和取得属性内容的操作    </p><h5 id="三、反射的优缺点"><a href="#三、反射的优缺点" class="headerlink" title="三、反射的优缺点"></a>三、反射的优缺点</h5><p>​    优点：可以实现动态创建对象和编译，体现出很大的灵活性<br>​    缺点：对性能有影响，反射是解释型操作，比直接进行操作还是慢一点</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础及入门</title>
      <link href="/posts/aci2.html"/>
      <url>/posts/aci2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring基础及入门"><a href="#Spring基础及入门" class="headerlink" title="Spring基础及入门"></a>Spring基础及入门</h1><h2 id="一、Spring框架概述"><a href="#一、Spring框架概述" class="headerlink" title="一、Spring框架概述"></a>一、Spring框架概述</h2><h5 id="1、Spring：是一个分层的-Java-EE-full-stack-一站式-轻量级开源的-Java-EE-框架"><a href="#1、Spring：是一个分层的-Java-EE-full-stack-一站式-轻量级开源的-Java-EE-框架" class="headerlink" title="1、Spring：是一个分层的 Java EE full-stack(一站式) 轻量级开源的 Java EE 框架"></a>1、Spring：是一个<strong>分层的 Java EE full-stack(一站式) 轻量级开源的 Java EE 框架</strong></h5><h5 id="2、为什么用它：Spring-使-Java-编程更快、更容易、更安全"><a href="#2、为什么用它：Spring-使-Java-编程更快、更容易、更安全" class="headerlink" title="2、为什么用它：Spring 使 Java 编程更快、更容易、更安全"></a>2、为什么用它：Spring 使 Java <strong>编程更快</strong>、<strong>更容易</strong>、<strong>更安全</strong></h5><h5 id="3、Spring的核心部分："><a href="#3、Spring的核心部分：" class="headerlink" title="3、Spring的核心部分："></a>3、Spring的核心部分：</h5><p>​        ① IOC：控制反转，把创建的对象的过程交给Spring进行管理<br>​                        底层原理：xml解析、工厂模式、反射<br>​        ② AOP：面向切面，不修改源码进行功能增强<br>​        ③ DI：依赖注入，在 spring 框架负责创建 Bean 对象时，动态的将依赖对象注入到 Bean 组件中目的都是为了降低代码耦合度</p><h5 id="4、Spring特点"><a href="#4、Spring特点" class="headerlink" title="4、Spring特点:"></a>4、Spring特点:</h5><p>​        （1）方便解耦，简化开发<br>​        （2）AOP 编程支持<br>​        （3）方便程序测试<br>​        （4）方便和其他框架进行整合<br>​        （5）方便进行事务操作<br>​        （6）降低 API 开发难度</p><h4 id="二、创建Spring容器"><a href="#二、创建Spring容器" class="headerlink" title="二、创建Spring容器"></a>二、创建Spring容器</h4><p>​    两种方式：<br>​        1、BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</p><p>​        2、ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用加载配置文件时候就会把在配置文件对象进行创建<br>​        ApplicationContext：Spring的上下文</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ApplicationContext</span> ap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileSystemXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"xml绝对路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ApplicationContext</span> ap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"xml相对路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    一、SpringBean的概述<br>​    SpringBean的概述：Spring Bean 是一个被实例化、组装并通过 Spring IOC 容器所管理的对象；它是构成 Spring 应用程序的支柱；简单来说就是一个Java类</p><h2 id="二、SpringBean的管理"><a href="#二、SpringBean的管理" class="headerlink" title="二、SpringBean的管理"></a>二、SpringBean的管理</h2><h4 id="1、Bean管理的三种方式"><a href="#1、Bean管理的三种方式" class="headerlink" title="1、Bean管理的三种方式"></a>1、Bean管理的三种方式</h4><p>​        ① 基于XML的配置文件<br>​        ② 基于注解的配置<br>​        ③ 基于java的配置</p><h4 id="2、IOC对Bean的管理（XML）"><a href="#2、IOC对Bean的管理（XML）" class="headerlink" title="2、IOC对Bean的管理（XML）"></a>2、IOC对Bean的管理（XML）</h4><p>​           ① 基于xml方式创建对象<br>​        <bean id="user" class="类全路径"></bean><br>​        （1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建。<br>​        （2）在 bean 标签有很多属性，介绍常用的属性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">*</span> id 属性：唯一标识<span class="token operator">*</span> <span class="token keyword">class</span> 属性：类全路径（包类路径）（<span class="token number">3</span>）创建对象时候，默认也是执行无参数构造方法完成对象创建。      ② 基于xml方式注入属性（<span class="token number">1</span>）基于构造函数的依赖注入在bean标签里写这个标签：      <span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg value<span class="token operator">=</span><span class="token string">"赋给属性的值"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">&gt;</span>（<span class="token number">2</span>）基于设值函数的依赖注入在bean标签里写这个标签：<span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"属性名"</span> value<span class="token operator">=</span><span class="token string">"赋给属性的值"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、SpringBean的作用域"><a href="#3、SpringBean的作用域" class="headerlink" title="3、SpringBean的作用域"></a>3、SpringBean的作用域</h4><p>​    *singleton     在 spring IOC 容器仅存在一个 Bean 实例，Bean 以单例方式存在，默认值<br>​    *prototype     每次从容器中调用 Bean 时，都返回一个新的实例，即每次调用getBean()时，相当于执行 newXxxBean()<br>​    request         每次 HTTP 请求都会创建一个新的 Bean，该作用域仅适用于WebApplicationContext 环境<br>​    session         同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同的 Bean，仅适用 WebApplicationContext 环境<br>​    global        session一般用于 Portlet 应 用 环 境 ， 该 运 用 域 仅 适 用 于WebApplicationContext 环境</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>、singleton 和 prototype 区别 ① singleton 单实例，prototype 多实例。② 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象。③ 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象<span class="token number">2</span>、<span class="token class-name">Bean</span>的生命周期① 创建：通过构造器或工厂方法创建 <span class="token class-name">Bean</span> 实例② 调用属性及设置属性的值③ 初始化<span class="token class-name">Bean</span>④ 使用<span class="token class-name">Bean</span>（执行业务逻辑）⑤ 销毁<span class="token class-name">Bean</span><span class="token number">3</span>、延迟初始化<span class="token class-name">Bean</span>在<span class="token class-name">Bean</span>标签里加这个属性：lazy<span class="token operator">-</span>init<span class="token operator">=</span><span class="token string">"true"</span><span class="token punctuation">;</span>提前实例化方式是好事，因为配置中或者运行环境的错误就会被立刻发现。延迟初始化 bean 会告诉 IOC 容器在第一次需要的时候才实例化而不是在容器启动时就实例化<span class="token number">4</span>、自动装配属性① 在<span class="token class-name">Bean</span>标签里加这个属性：autowire<span class="token operator">=</span><span class="token string">"byType/byName/constructor"</span><span class="token punctuation">;</span>② byName：根据名字自动装配byType：根据属性类别自动装配constructor：通过构造器进行自动装配③ 优缺点：优点：简化了开发步骤缺点：autowire 属性要么根据类型，要么根据名称自动装配，不能二者兼而有之。基于xml 配置的 spring 工程，很少使用自动装配。而基于注解的 spring 工程，还是会用到自动装配。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、SpingJdbcTemplate"><a href="#4、SpingJdbcTemplate" class="headerlink" title="4、SpingJdbcTemplate"></a>4、SpingJdbcTemplate</h4><h5 id="XML的配置"><a href="#XML的配置" class="headerlink" title="XML的配置"></a>XML的配置</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 注册数据访问层实现类 <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"数据访问层实现类名"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"数据访问层实现类的绝对路径"</span> p<span class="token operator">:</span>temp<span class="token operator">-</span>ref<span class="token operator">=</span><span class="token string">"JdbcTemplate的属性名"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 注册<span class="token class-name">JDBCTemplte</span> <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"temp"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.jdbc.core.JdbcTemplate"</span> p<span class="token operator">:</span>dataSource<span class="token operator">-</span>ref<span class="token operator">=</span><span class="token string">"dataSource"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 注册数据源 <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"dataSource"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"driverClassName"</span> value<span class="token operator">=</span><span class="token string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">&gt;</span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"url"</span> value<span class="token operator">=</span><span class="token string">"jdbc:mysql:///employee"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">&gt;</span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"username"</span> value<span class="token operator">=</span><span class="token string">"root"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">&gt;</span><span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"password"</span> value<span class="token operator">=</span><span class="token string">"root"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、AOP概述"><a href="#三、AOP概述" class="headerlink" title="三、AOP概述"></a>三、AOP概述</h2><p>​    概念：<strong>面向切面，把业务逻辑和系统级服务分开，可以把AOP看作一个插件，在不改变源码的基础上把一些功能进行增强或添加</strong></p><h4 id="二、AOP原理"><a href="#二、AOP原理" class="headerlink" title="二、AOP原理"></a>二、AOP原理</h4><p>​    原理：<strong>动态代理</strong><br>​    </p><h4 id="三、AOP名词"><a href="#三、AOP名词" class="headerlink" title="三、AOP名词"></a>三、AOP名词</h4><p>​    切面：一个模块<br>​    织入：把切面代码插入到目标对象某个方法的过程<br>​    连接点：被织入的点，一个方法的前后<br>​    切入点：实际被切面织入的点<br>​    目标对象：切入点和连接点所属的类，被通知的对象<br>​    通知：切面要完成的功能<br>​    代理：向目标对象应用通知之后创建的对象</p><h4 id="四、AspectJ（基于java的AOP框架）"><a href="#四、AspectJ（基于java的AOP框架）" class="headerlink" title="四、AspectJ（基于java的AOP框架）"></a>四、AspectJ（基于java的AOP框架）</h4><h5 id="1、通知类型"><a href="#1、通知类型" class="headerlink" title="1、通知类型"></a>1、通知类型</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Before</span> <span class="token comment">// 前置通知</span><span class="token annotation punctuation">@AfterReturning</span>  <span class="token comment">// 后置通知</span><span class="token annotation punctuation">@Around</span> <span class="token comment">// 环绕通知</span><span class="token annotation punctuation">@AfterThrowing</span>  <span class="token comment">// 抛出通知</span><span class="token annotation punctuation">@After</span> <span class="token comment">// 最终 final 通知，不管是否异常，该通知都会执行无论程序是否正常执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、切入点表达式（标识切面织入到哪些类的那些方法当中，通过-execution-函数，可以定义切点的方法切入）"><a href="#2、切入点表达式（标识切面织入到哪些类的那些方法当中，通过-execution-函数，可以定义切点的方法切入）" class="headerlink" title="2、切入点表达式（标识切面织入到哪些类的那些方法当中，通过 execution 函数，可以定义切点的方法切入）"></a>2、切入点表达式（标识切面织入到哪些类的那些方法当中，通过 execution 函数，可以定义切点的方法切入）</h5><p>​    ① 语法：execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)    — 如果没有这些参数可以不写，访问修饰符和java一样<br>​    ② 特殊符号<br>​        * 代表 0 到多个任意字符<br>​        .. 放在方法参数中, 代表任意参数, 放在包名称后面表示当前包及其所有子包路径<br>​        + 放在类名后, 表示当前 Java 类及其子类, 放在接口后, 表示当前接口及其实现类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 举几个常用的栗子</span><span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>zb<span class="token punctuation">.</span>dao<span class="token punctuation">.</span></span>UserDao</span><span class="token punctuation">.</span>*<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 表示dao包下面的UserDao类下的任意方法</span><span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> com<span class="token punctuation">.</span>zb<span class="token punctuation">.</span>dao<span class="token punctuation">.</span><span class="token punctuation">.</span>*<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 表示dao包下面的任意类的任意方法</span><span class="token function">execution</span><span class="token punctuation">(</span><span class="token keyword">public</span> <span class="token operator">*</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 表示任意public修饰的方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3、环境搭建"><a href="#3、环境搭建" class="headerlink" title="3、环境搭建"></a>3、环境搭建</h5><p>​    导3个包（aspectjweaver-1.7.4.RELEASE.jar、spring-aspects-5.2.13.RELEASE.jar、aopalliance-1.0.jar）</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">① xml配置文件的方式<span class="token comment">&lt;!-- 配置AOP增强 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 切入点 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> 切入点表达式 <span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>book<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!-- 配置切面 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspect</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bookProxy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 织入：增强作用到方法上before:提前通知 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>before</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> 要织入的Bean对象名 <span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> 切入点名 <span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspect</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span>② 注解方式<span class="token comment">&lt;!-- 包扫描器 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.zb<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 自动代理 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>aspectj-autoproxy</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">③ java配置文件的方式  <span class="token annotation punctuation">@Configuration</span>  <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"要扫描的包路径"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token punctuation">(</span>proxyTargetClass <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment">// 自动代理对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、Spring事务"><a href="#四、Spring事务" class="headerlink" title="四、Spring事务"></a>四、Spring事务</h2><h4 id="一、事务概述"><a href="#一、事务概述" class="headerlink" title="一、事务概述"></a>一、事务概述</h4><p>​    概念：<strong>一系列的动作，可以当成一个单独的工作单元，这一系列的动作要么全部完成要么不完成</strong><br>​    </p><h4 id="二、事务的属性"><a href="#二、事务的属性" class="headerlink" title="二、事务的属性"></a>二、事务的属性</h4><p>​    ① 原子性：某个一系列的动作要么全部完成要么不完成<br>​    ② 一致性：一旦事务动作完成，事务就被提交，数据和资源就处于一种满足业务规则的状态中<br>​    ③ 隔离性：每个事务都应该是独立的，这样可以防止数据的损坏<br>​    ④ 持久性：一旦事务完成，无论发生什么错误，结果都不应该受到影响，事务的结果会写到持久化储存器中</p><h4 id="三、事务的分类"><a href="#三、事务的分类" class="headerlink" title="三、事务的分类"></a>三、事务的分类</h4><p>​    ① 编程式事务：将事务管理的代码嵌入到业务方法中来控制事务的提交和回滚，这样降低了代码的重用性，提高了耦合度，不便于维护<br>​    ② 声明式事务：将事务管理的代码分离出来，Spring通过Spring AOP框架来实现作为一个切面来使用，使其模块化，这样提高了代码的重用性，降低了代码的耦合度，便于后期维护<br>​    </p><h4 id="四、Spring事务实现-—-注解方式"><a href="#四、Spring事务实现-—-注解方式" class="headerlink" title="四、Spring事务实现 — 注解方式"></a>四、Spring事务实现 — 注解方式</h4><h6 id="第一步：导入事务包（spring-tx-5-2-13-RELEASE-jar）"><a href="#第一步：导入事务包（spring-tx-5-2-13-RELEASE-jar）" class="headerlink" title="第一步：导入事务包（spring-tx-5.2.13.RELEASE.jar）"></a>第一步：导入事务包（spring-tx-5.2.13.RELEASE.jar）</h6><h6 id="第二步：xml配置"><a href="#第二步：xml配置" class="headerlink" title="第二步：xml配置"></a>第二步：xml配置</h6><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 配置bean的扫描器 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.zb<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 注册JDBCTemplte --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>temp<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.core.JdbcTemplate<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>dataSource-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:db.properties<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!-- 注册数据源 --&gt;</span><span class="token comment">&lt;!-- 配置文件代码 --&gt;</span><span class="token comment">&lt;!--jdbc.driverClassName=org.springframework.jdbc.datasource.DriverManagerDataSourcejdbc.url=jdbc:mysql:///testjdbc.username=rootjdbc.password=root--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DriverManagerDataSource<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.driverClassName}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.url}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.username}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.password}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 注册事务管理器 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txMgr<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 开启事务注解驱动 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txMgr<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="第三步：使用注解"><a href="#第三步：使用注解" class="headerlink" title="第三步：使用注解"></a>第三步：使用注解</h6><h4 id="五、事务的属性"><a href="#五、事务的属性" class="headerlink" title="五、事务的属性"></a>五、事务的属性</h4><h5 id="1、事务的传播属性（7种）"><a href="#1、事务的传播属性（7种）" class="headerlink" title="1、事务的传播属性（7种）"></a>1、事务的传播属性（7种）</h5><p>​        （常用）① REQUIRED：如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行，从始至终只有一个事务<br>​        （常用）② REQUIRED_NEW：当前方法必须启动新事务，并在他自己的事务内运行，如果用事务正在运行，应该将这个事务挂起<br>​        ③ SUPPORTS：如果有事务在运行，当前的方法就在这个事务内运行，否则他不可以运行在这个事务中<br>​        ④ NOT_SUPPORTS：当前的方法不应该运行在事务中，如果有运行的事务，将它挂起<br>​        ⑤ MANDATORY：当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常<br>​        ⑥ NEVER：当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常<br>​        ⑦ NESTED：如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在他自己的事务内运行</p><h5 id="2、事务的隔离级别"><a href="#2、事务的隔离级别" class="headerlink" title="2、事务的隔离级别"></a>2、事务的隔离级别</h5><p>​    ① 事务并发产生的问题名词解释<br>​        脏读：一个事务读取到了另一个事务没有提交的数据（不能容忍）<br>​        不可重复读：在同一个事务中两次读取同一数据，得到的内容不一样（可以容忍）<br>​        幻读：同一事务，用同一种操作，得到的记录数不同（可以容忍）<br>​    ② 隔离级别<br>​        DEFAULT：表示隔离级别位数据库默认的（READ_COMMITTED）<br>​        READ_UNCOMMITTED：表示允许读取尚未提交的更改，可能导致脏读、但幻读或不可重复读<br>​        READ_COMMITTED：表示从已经提交的并发事务读取，可以避免脏读，但是不可重复读和幻读可能会出现<br>​        REPEATABLE_READ：表示事务对相同字段的多次读取的结果是一致的，这个事务持续期间禁止其他事务修改这字段，除非数据被当前事务本身改变，可以避免脏读和不可重复读，但幻读可能会出现<br>​        SERIALIZABLE：表示完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻读但是性能低下        ACID：事务的特征<br>​        mysql只支持前面4种，Oracle支持二种：READ_COMMITTED，SERIALIZABLE：</p><h5 id="六、事务中的异常（自定义的异常类）"><a href="#六、事务中的异常（自定义的异常类）" class="headerlink" title="六、事务中的异常（自定义的异常类）"></a>六、事务中的异常（自定义的异常类）</h5><p>​    最好抛出 RuntimeException。<br>​    如果抛出 Exception，同时在事务声明中加上@Transactional(rollbackFor = Exception.class)。<br>​    事务只会捕获 RuntimeException。对于Exception 不进行事务回滚</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客订阅文章通知功能</title>
      <link href="/posts/ebb2.html"/>
      <url>/posts/ebb2.html</url>
      
        <content type="html"><![CDATA[<p>一直有小伙伴催我要我写教程，关于如何实现博客文章订阅的功能，并进行推送的功能，我接触这个也不久，百度一番，最终配置成功。手动艾特我群里的那些小伙伴，教程来了😂，</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub下载慢加速</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Github-下载慢加速"><a href="#Github-下载慢加速" class="headerlink" title="Github 下载慢加速"></a>Github 下载慢加速</h2><p>解决GitHub 下载 release 资源太慢的办法</p><h3 id="1-使用下载器下载"><a href="#1-使用下载器下载" class="headerlink" title="1. 使用下载器下载"></a>1. 使用下载器下载</h3><p>  复制 release 资源链接，使用 <code>迅雷</code> 或者 <code>Free Download Manager</code> 直接下载 <a href="http://github.com/">http://github.com</a> 开头的原链接。<br>  使用迅雷下载不是很稳定，有时候速度可以秒下，有时候下载不下来。可以多试几次。 FDM暂时还没测试过。</p><p>优点： 有资源时可以下载快，从官方原链接下载，安全性可靠性相对较好</p><p>不足： 依赖下载器，需要看资源情况</p><h3 id="2-使用代下载服务l"><a href="#2-使用代下载服务l" class="headerlink" title="2. 使用代下载服务l"></a>2. 使用代下载服务l</h3><p>  复制 release 资源链接，使用github 代下载 ：</p><p>​    <a href="http://gitd.cc/">http://gitd.cc/</a><br>​    <a href="http://github.b15.me/">http://github.b15.me/</a><br>优点： 不需要下载器，随时都可以打开网站使用</p><p>不足： 网站可用性、安全性可靠性取决于代下载服务，文件会被二次压缩，且下载文件名会改变</p><h3 id="3-Github下载加速插件"><a href="#3-Github下载加速插件" class="headerlink" title="3. Github下载加速插件"></a>3. Github下载加速插件</h3><p>  安装gitHub加速插件：</p><p><a href="https://fhefh2015.github.io/Fast-GitHub/">https://fhefh2015.github.io/Fast-GitHub/</a></p><h3 id="4-使用GitHub-反代域名替换"><a href="#4-使用GitHub-反代域名替换" class="headerlink" title="4. 使用GitHub 反代域名替换"></a>4. 使用GitHub 反代域名替换</h3><p>  使用GitHub 反代域名替换</p><p><a href="https://fastgit.org/">https://fastgit.org/</a><br><a href="https://www.gitclone.com/">https://www.gitclone.com</a><br><a href="https://cdn.con.sh/">https://cdn.con.sh</a><br><a href="http://gitcdn.link/">http://gitcdn.link/</a></p><h2 id="Github-访问慢加速"><a href="#Github-访问慢加速" class="headerlink" title="Github 访问慢加速"></a>Github 访问慢加速</h2><p>内容整理来自网络。</p><h3 id="1、获取相关域名"><a href="#1、获取相关域名" class="headerlink" title="1、获取相关域名"></a>1、获取相关域名</h3><p>获取Github相关网站的域名。</p><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>访问 <a href="https://github.com/">https://github.com</a></p><p>F12 查看网络，查看域名。</p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>直接访问：<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com</a></p><h4 id="2、获取相关域名对应IP"><a href="#2、获取相关域名对应IP" class="headerlink" title="2、获取相关域名对应IP"></a>2、获取相关域名对应IP</h4><p>访问 <a href="https://www.ipaddress.com/">https://www.ipaddress.com</a></p><p>分别输入</p><p>github.global.ssl.fastly.net<br>github.com</p><p>查询ip地址</p><h3 id="3、配置hosts"><a href="#3、配置hosts" class="headerlink" title="3、配置hosts"></a>3、配置hosts</h3><p>windows 系统的 hosts 文件的位置如下：C:\Windows\System32\drivers\etc\hosts ;</p><p>mac/linux 系统的 hosts 文件的位置如下：/etc/hosts 。</p><p>下面是我的配置，更新日期 2020-09-20</p><pre class="line-numbers language-none"><code class="language-none">140.82.112.3 github.com199.232.69.194 github.global.ssl.fastly.net199.232.68.133  githubusercontent.com185.199.108.153 assets-cdn.github.com185.199.109.153 assets-cdn.github.com185.199.110.153 assets-cdn.github.com185.199.111.153 assets-cdn.github.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、刷新DNS"><a href="#4、刷新DNS" class="headerlink" title="4、刷新DNS"></a>4、刷新DNS</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig /flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应该快点了吧？</p><p>隔一段时间查一次，IP 不会一直不变，不定期更新。</p><h3 id="5、DNS命令解析IP"><a href="#5、DNS命令解析IP" class="headerlink" title="5、DNS命令解析IP"></a>5、DNS命令解析IP</h3><p>DNS查看</p><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">ipconfig /all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>底下可以看到 DNS 服务器IP相关信息。</p><p>指定DNS 解析域名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nslookup</span> github.com  <span class="token number">8.8</span>.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能显示出DNS服务器IP，说明github.com 是可以访问的，可以尝试修改自己电脑DNS再试试。</p><pre class="line-numbers language-none"><code class="language-none">谷歌：8.8.8.8阿里：223.5.5.5 或 223.6.6.6114 : 114.114.114.114百度:180.76.76.76360 : 101.226.4.5南方电信: 180.153.225.136北京联通 202.106.0.20 202.106.196.115<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig /flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo+GitHub Page 搭建博客</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><pre><code>         收到很多留言和联系我怎么搭建一个博客，但是由于学习比较忙，所有就没有给大家都回复到，还有很多同学想让我给搭建博客，但是我觉得授人以鱼不如授人以渔，所以整理出来一些我搭建过程中的主要步骤。在之后如果有时间或者有人想要看我是如何改的博客样式的，可以留言和评论，我再给出教程，在按照步骤搭建的过程中遇到问题也可以联系我。</code></pre><h4 id="1-安装工具"><a href="#1-安装工具" class="headerlink" title="1.安装工具"></a>1.安装工具</h4><p>在搭建博客的前期需要安装相关的工具分别是node和git，这两个工具都可以在官网上面下载，安    装和配置可以在网上自行搜索。</p><h4 id="2-注册github账号"><a href="#2-注册github账号" class="headerlink" title="2.注册github账号"></a>2.注册github账号</h4><p>因为我们要搭建的是一个静态博客，所有要把文件都放在GitHub的仓库里，所以需要注册一个    GitHub账号以及新建一个GitHub仓库，这个比较简单可以自行搜索。</p><ul><li>这里有一个要注意的环节就是在建立仓库的时候仓库名必须是<code>用户名.github.io</code></li><li>在仓库有一个index.html文件时，在浏览器中输入<code>https://用户名.github.io</code>就可以看到index.html里的内容，github pages就创建好了（这一步只是试验，不是必须操作）</li></ul><h4 id="3-配置git用户信息"><a href="#3-配置git用户信息" class="headerlink" title="3. 配置git用户信息"></a>3. 配置git用户信息</h4><p>​    打开git输入</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name "你的github用户名"git config --global user.email "你的github邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-安装hexo静态博客框架发布到github-pages"><a href="#4-安装hexo静态博客框架发布到github-pages" class="headerlink" title="4.安装hexo静态博客框架发布到github pages"></a>4.安装hexo静态博客框架发布到github pages</h4><p>打开git输入</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-clihexo init 文件夹名cd 文件夹名npm install <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>后续操作都在上面新建的文件夹里操作</p><p>hexo框架的本地搭建完成之后就输入命令查看效果（不是必要操作）</p><pre class="line-numbers language-none"><code class="language-none">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-将本地博客发布到github-pages中"><a href="#5-将本地博客发布到github-pages中" class="headerlink" title="5.将本地博客发布到github pages中"></a>5.将本地博客发布到github pages中</h4><p>下载安装发布的插件</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将本地目录和github关联起来</p><p>生成秘钥和公钥</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C "你的github邮件地址"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一直回车，在提示目录下找到.ssh文件夹， 把公钥也就是id_rsa.pub中的内容复制到github的setting里的SSH and GPG keys中添加</li></ul><p>测试链接是否成功</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-配置站点目录并发布"><a href="#6-配置站点目录并发布" class="headerlink" title="6.配置站点目录并发布"></a>6.配置站点目录并发布</h4><p>用编辑器打开_config.yml文件，对博客进行个性化配置</p><pre class="line-numbers language-none"><code class="language-none">title: 你的博客名 subtitle: 博客的副标题，有些主题支持 description: 博客描述keywords: 博客关键词 author: 作者，在文章中显示 language: 博客语言语种 timezone: 时区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在文件的最低部添加repo项和branch项，并添加如下信息</p><pre class="line-numbers language-none"><code class="language-none">type: git repo: git@github.com:Github用户名/github用户名.github.io.git//也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后就是生成页面并且发布在github pages上，（之后写文章放在/source/_posts/目录下也上下面这三条命令上传)</p><pre class="line-numbers language-none"><code class="language-none">hexo clean    //清缓存hexo g        //渲染hexo d        //上传hexo clean &amp;&amp; hexo g -d//这是三条一起运行的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这时候打开<code>https://用户名.github.io</code>你就可以看到你的博客已经更新了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
