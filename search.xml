<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue语法及入门基础</title>
      <link href="/posts/3fde.html"/>
      <url>/posts/3fde.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="一、什么是Vue？"><a href="#一、什么是Vue？" class="headerlink" title="一、什么是Vue？"></a>一、什么是Vue？</h2><p>动态构建用户界面的渐进式 JavaScript 框架。</p><h2 id="二、模板语法"><a href="#二、模板语法" class="headerlink" title="二、模板语法"></a>二、模板语法</h2><h3 id="1-插值语法"><a href="#1-插值语法" class="headerlink" title="1. 插值语法"></a>1. 插值语法</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">// 用于解析标签体内容&lt;h1&gt;{{xxx}}&lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-指令语法"><a href="#2-指令语法" class="headerlink" title="2. 指令语法"></a>2. 指令语法</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">// 解析标签属性、解析标签体内容、绑定事件&lt;a v-bind:href="xxx"&gt;百度&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、数据绑定"><a href="#三、数据绑定" class="headerlink" title="三、数据绑定"></a>三、数据绑定</h2><h3 id="1-单向数据绑定"><a href="#1-单向数据绑定" class="headerlink" title="1.单向数据绑定"></a>1.单向数据绑定</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 语法 --&gt;&lt;!-- 或简写为 :href --&gt;&lt;p v-bind:href ="xxx"&gt;&lt;/p&gt;&lt;!-- 特点：数据只能从 data 流向页面 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-双向数据绑定"><a href="#2-双向数据绑定" class="headerlink" title="2.双向数据绑定"></a>2.双向数据绑定</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 语法 --&gt;&lt;!-- 或简写为  v-model="xxx" --&gt;&lt;p v-model:value ="xxx"&gt;&lt;/p&gt;&lt;!-- 数据不仅能从 data 流向页面，还能从页面流向 data --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、MVVM-模型"><a href="#四、MVVM-模型" class="headerlink" title="四、MVVM 模型"></a>四、MVVM 模型</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            M：模型(Model) ：对应 data 中的数据</p><p>​            V：视图(View) ：模板</p><p>​            VM：视图模型(ViewModel) ： Vue 实例对象</p><p><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211021192325645.png" alt="MVVM模型"></p><p>解释：</p><p><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211021192350130.png" alt="模型解释"></p><h2 id="五、事件处理和事件、按键修饰符"><a href="#五、事件处理和事件、按键修饰符" class="headerlink" title="五、事件处理和事件、按键修饰符"></a>五、事件处理和事件、按键修饰符</h2><h3 id="1-事件处理"><a href="#1-事件处理" class="headerlink" title="1. 事件处理"></a>1. 事件处理</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 语法 --&gt;&lt;p v-on:事件名="函数名(参数或无参)"&gt;&lt;/p&gt;&lt;!-- 简略写法 --&gt;&lt;p @事件名="函数名(参数或无参)"&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-事件修饰符"><a href="#2-事件修饰符" class="headerlink" title="2. 事件修饰符"></a>2. 事件修饰符</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- prevent阻止事件的默认行为 --&gt;&lt;a href="https://www.baidu.com" @click.prevent="函数名()"&gt;点我到百度&lt;/a&gt;&lt;!-- 阻止事件冒泡 --&gt;&lt;div class="apps" @click="showInfo()"&gt;    &lt;!-- stop：阻止事件冒泡 --&gt;    &lt;!-- 链式写法 --&gt;    &lt;button type="button" @click.stop.prevent="函数名()"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;!-- once：事件只能触发一次 --&gt;&lt;button type="button" @click.once="函数名()"&gt;点我&lt;/button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-按键修饰符"><a href="#3-按键修饰符" class="headerlink" title="3. 按键修饰符"></a>3. 按键修饰符</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 指定按键，键码或者键名都行,键的别名也行 --&gt;&lt;!-- Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态事件通常与函数结合使用，函数不会在事件发生前被执行 --&gt;&lt;input type="text" name="" id="" value="" @keydown.键名="showInfo($event)" placeholder="按下回车提示输入....." /&gt;&lt;!-- 自定义键名 --&gt;&lt;!-- 声明一个键别名，键码为13 --&gt;Vue.config.keyCodes.huiche = 13;new Vue({......});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、计算属性"><a href="#六、计算属性" class="headerlink" title="六、计算属性"></a>六、计算属性</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            <strong>在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以</strong>，要显示的数据不存在，要通过计算得来，计算属性其实和函数没什么区别</p><h3 id="2-声明和使用计算属性"><a href="#2-声明和使用计算属性" class="headerlink" title="2. 声明和使用计算属性"></a>2. 声明和使用计算属性</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    new Vue({        el : "#app",        // 每个计算属性中默认有get和set方法，可以写也可以不写        computed:{// 计算属性            fullName : {                get(){// 当使用fullName这个计算属性时就会调用此get方法                    console.log("get方法被调用了!");                    return this.fistName +"-"+ this.lastName;                },                set(value){// fullName这个计算属性发生发生改变时就会调用此set方法                    console.log("set方法", value);                }            }       },    });    // 使用计算属性：{{计算属性名}}可以触发get方法    // v-model="计算属性名" 可以触发set方法&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-计算属性缓存和函数（方法）的区别"><a href="#3-计算属性缓存和函数（方法）的区别" class="headerlink" title="3. 计算属性缓存和函数（方法）的区别"></a>3. 计算属性缓存和函数（方法）的区别</h3><p>​            两者最主要的区别：computed 是<strong>可以缓存的</strong>，methods <strong>不能缓存</strong>；<strong>只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，就不会多次执行。</strong></p><h3 id="4-计算属性通过闭包方式传参"><a href="#4-计算属性通过闭包方式传参" class="headerlink" title="4. 计算属性通过闭包方式传参"></a>4. 计算属性通过闭包方式传参</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    computed: {        closure () {            return function (a, b, c) {                .......                return data;            }        }    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、监听（侦听）属性"><a href="#七、监听（侦听）属性" class="headerlink" title="七、监听（侦听）属性"></a>七、监听（侦听）属性</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            顾名思义，监听某个属性的变化并对其进行一些操作，Watch中可以执行任何逻辑，如函数节流、Ajax异步获取数据，甚至操作 DOM（不建议）</p><h3 id="2-声明及用法"><a href="#2-声明及用法" class="headerlink" title="2. 声明及用法"></a>2. 声明及用法</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- HTML --&gt;&lt;div id="app"&gt;    姓：&lt;input type="text" name="" id="" value="" v-model="fistName" /&gt;&lt;br /&gt;    名：&lt;input type="text" name="" id="" value="" v-model="lastName" /&gt;&lt;br /&gt;    &lt;p&gt;全名：{{fistName}} - {{lastName}} &lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    new Vue({        el : '#app',        data : {            fistName : "阿",            lastName : "龟"        },        watch:{// 监视属性，当fistName或lastName发生改变时就会触发监视属性            fistName : {                deep : true,//  deep：需要监听的数据的深度，一般用来监听对象中某个属性的变化,数组字符串一般不需要                // 在选项参数中指定 immediate: true将立即以表达式的当前值触发回调,                immediate : false,// 初始化，调用一次handler                // 第一个参数为新值，第二个参数为旧值，如果调用的旧值会发生无限更新值的情况                handler(newValue, oldValue){// handle：watch中需要具体执行的方法                    console.log(oldValue, newValue);                    this.fistName = newValue;                }            },            lastName : {                handler(newValue, oldValue){                    console.log(oldValue, newValue);                    this.lastName = newValue;                }            }        }    });&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、计算属性和监视属性的总结"><a href="#八、计算属性和监视属性的总结" class="headerlink" title="八、计算属性和监视属性的总结"></a>八、计算属性和监视属性的总结</h2><h3 id="1-计算属性和监视属性的区别"><a href="#1-计算属性和监视属性的区别" class="headerlink" title="1.计算属性和监视属性的区别"></a>1.计算属性和监视属性的区别</h3><p>​            ① computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</p><p>​            ② watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作</p><p>​            主要区别：</p><p>​                <strong>计算属性不能执行异步任务，计算属性必须同步执行</strong>，而监视属性可以实现异步</p><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>​            ① 计算属性能做的监视属性也能做，反之则不行</p><p>​            ② 尽量使用计算属性来替代监视属性</p><h2 id="九、class-与-style-绑定"><a href="#九、class-与-style-绑定" class="headerlink" title="九、class 与 style 绑定"></a>九、class 与 style 绑定</h2><h3 id="1-概念：字面意思"><a href="#1-概念：字面意思" class="headerlink" title="1.概念：字面意思"></a>1.概念：字面意思</h3><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;class 与 style 绑定&lt;/title&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt;&lt;style&gt;.c1{color: red;}.c2{font-size: 30px;}.c3{font-weight: 600;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;ul&gt;&lt;li :class="cl1"&gt;aguiagu&lt;/li&gt;&lt;li :class="['c1', 'c2', 'c3']"&gt;fas&lt;/li&gt;&lt;li :style="{color: colors, 'font-weight': fonts}"&gt;erwe&lt;/li&gt;&lt;li :style="styleList"&gt;fsa&lt;/li&gt;&lt;li :class="{c1:t}"&gt;gsdfg&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;new Vue({el : "#app",data : {cl1 : 'c1',cl2 : 'c2',cl3 : 'c3',t : true,f : false,colors : 'blue',fonts : 800,styleList : {// 属性集合color : 'green',fontWeight : 900}}})&lt;/script&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、条件渲染"><a href="#十、条件渲染" class="headerlink" title="十、条件渲染"></a>十、条件渲染</h2><h3 id="1-v-if和v-show"><a href="#1-v-if和v-show" class="headerlink" title="1. v-if和v-show"></a>1. v-if和v-show</h3><p>​        ① 概念：都相当于相当于Java中的if-else</p><p>​        ② 原理：</p><p>​                v-show指令：元素始终被渲染到HTML，它只是简单的伪元素设置css的style属性，当不满足条件的元素被设置style=“display：none”的样，是通过修改元素的的CSS属性(display)来决定实现显示还是隐藏</p><p>​                v-if指令：满足条件是会渲染到html中，不满足条件时是不会渲染到html中的，是通过操纵dom元素来进行切换显示</p><p>​        ③ 使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div id="app"&gt;    &lt;p v-if="ok"&gt;表白成功&lt;/p&gt;    &lt;p v-else&gt;表白失败&lt;/p&gt;    &lt;hr /&gt;    &lt;p v-show="ok"&gt;求婚成功&lt;/p&gt;    &lt;p v-show="!ok"&gt;求婚失败&lt;/p&gt;    &lt;button type="button" @click="ok = !ok"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    new Vue({        el:'#app',        data:{            ok: true        }    })&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-总结-1"><a href="#2-总结-1" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>​            如果频繁切换建议使用v-show</p><h2 id="十一、列表渲染"><a href="#十一、列表渲染" class="headerlink" title="十一、列表渲染"></a>十一、列表渲染</h2><h3 id="1-v-for"><a href="#1-v-for" class="headerlink" title="1. v-for"></a>1. v-for</h3><p>​            ① 概念：相当于Java中的for循环</p><p>​            ② 使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;列表渲染&lt;/title&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;!-- 数组遍历 --&gt;&lt;h1&gt;遍历人员&lt;/h1&gt;&lt;table border="" cellspacing="" cellpadding=""&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;age&lt;/th&gt;&lt;/tr&gt;&lt;tr v-for="(p, index) of persons" :key="index"&gt;&lt;td&gt;{{p.id}}&lt;/td&gt;&lt;td&gt;{{p.name}}&lt;/td&gt;&lt;td&gt;{{p.age}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- 遍历对象 --&gt;&lt;h1&gt;遍历对象&lt;/h1&gt;&lt;table border="" cellspacing="" cellpadding=""&gt;&lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;th&gt;color&lt;/th&gt;&lt;/tr&gt;&lt;tr v-for="(c, key, i) in cars" :key="key"&gt;&lt;!-- i是索引 --&gt;&lt;td&gt;{{c}}&lt;/td&gt;&lt;td&gt;{{c}}&lt;/td&gt;&lt;td&gt;{{c}}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- 遍历字符串 --&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;new Vue({el : "#app",data : {persons : [{id : "001", name : "Tom", age : 20},{id : "002", name : "Jack", age : 20},{id : "003", name : "Lisa", age : 20},{id : "004", name : "Dawei", age : 20},{id : "005", name : "agui", age : 20}],cars : {name : "比亚迪",price : 380000,color : "red"}},methods:{}})&lt;/script&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-数据过滤和排序"><a href="#2-数据过滤和排序" class="headerlink" title="2. 数据过滤和排序"></a>2. 数据过滤和排序</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    new Vue({        el : "#app",        data : {            persons : [                {id : "001", name : "Tom", age : 20},                {id : "002", name : "Jack", age : 20},                {id : "003", name : "Lisa", age : 20},                {id : "004", name : "Dawei", age : 20},                {id : "005", name : "agui", age : 20}            ],            keyWorld : ""        },        computed : {            fn(v){                // 使用filter过滤函数实现数据过滤                return this.persons.filter (k =&gt; {// k代表this                    return k.name.indexOf(this.keyWorld) !== -1;                });                                // 排序                if(orderType){                    persons.sort(function (a,b) {                        if(orderType===1){                            return a.age-b.age;                        }else{                            return b.age-a.age;                        }                    });                }            }        }    })&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十二、自定义指令"><a href="#十二、自定义指令" class="headerlink" title="十二、自定义指令"></a>十二、自定义指令</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>​            ① 一个指令对象的定义可以使用如下的几种钩子函数：</p><p>​                    <code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</p><p>​                    <code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</p><p>​                    <code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有</p><p>​                    <code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用</p><p>​                    <code>unbind</code>：只调用一次，指令与元素解绑时调用</p><h3 id="2-定义自定义指令"><a href="#2-定义自定义指令" class="headerlink" title="2.定义自定义指令"></a>2.定义自定义指令</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script type="text/javascript"&gt;    // 全局自定义指令，el指：指令所在的标签dom    Vue.directive('指令名', function(el, bind){        el.innerText = bind.value*100;    });   new Vue({        // 自定义局部指令        directives : {        big(el, bind){element.innerText = bind.value*100;}}    });&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十二、页面优化"><a href="#十二、页面优化" class="headerlink" title="十二、页面优化"></a>十二、页面优化</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- v-once所在节点的视为静态属性，只渲染一次，常用于优化页面 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-once</span><span class="token punctuation">&gt;</span></span>n的值为：{{n}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑，常用于页面优化 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-pre</span><span class="token punctuation">&gt;</span></span>{{n}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>n的值为：{{n}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>n++<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点我n+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十三、Vue的生命周期"><a href="#十三、Vue的生命周期" class="headerlink" title="十三、Vue的生命周期"></a>十三、Vue的生命周期</h2><ul><li><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211022164544216.png" alt="Vue生命周期"></li></ul><h1 id="Vue-cli：vue脚手架"><a href="#Vue-cli：vue脚手架" class="headerlink" title="Vue-cli：vue脚手架"></a>Vue-cli：vue脚手架</h1><h2 id="一、Vue组件化编程"><a href="#一、Vue组件化编程" class="headerlink" title="一、Vue组件化编程"></a>一、Vue组件化编程</h2><h3 id="1-模块与组件"><a href="#1-模块与组件" class="headerlink" title="1. 模块与组件"></a>1. 模块与组件</h3><p>​            1）模块</p><p>​                ① 理解: 向外提供特定功能的 JS 程序, 一般就是一个 JS 文件</p><p>​                ② 为什么？ JS 文件很多很复杂</p><p>​                ③ 作用：复用 JS, 简化 JS 的编写, 提高 JS 运行效率</p><p>​            2）组件</p><p>​                ① 理解：用来实现局部(特定)功能效果的代码集合(html/css/js/image…..)</p><p>​                ③ 为什么：一个界面的功能很复杂</p><p>​                ② 作用：复用编码, 简化项目编码, 提高运行效率</p><h3 id="2-模块化与组件化"><a href="#2-模块化与组件化" class="headerlink" title="2. 模块化与组件化"></a>2. 模块化与组件化</h3><p>​            1）模块化</p><p>​                当应用中的 JS 都以模块来编写的, 那这个应用就是一个模块化的应用</p><p>​            2）组件化</p><p>​                当应用中的功能都是多组件的方式来编写的， 那这个应用就是一个组件化的应用</p><h2 id="二、vue脚手架"><a href="#二、vue脚手架" class="headerlink" title="二、vue脚手架"></a>二、vue脚手架</h2><h3 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如果安装了旧版的vue/cli，先卸载</span><span class="token comment"># 方法一</span><span class="token function">npm</span> uninstall vue-cli -g<span class="token comment"># 方法二</span><span class="token function">yarn</span> global remove vue-cli<span class="token comment"># 安装</span><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli<span class="token comment"># 检查是否安装完成 ---&gt;  查看vue/cli版本</span>vue --version<span class="token comment"># 升级vue/cli版本（直接到最新版本）</span><span class="token function">npm</span> update -g @vue/cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-使用vue-cli创建vue项目"><a href="#3-使用vue-cli创建vue项目" class="headerlink" title="3. 使用vue/cli创建vue项目"></a>3. 使用vue/cli创建vue项目</h3><p>​            1）cmd方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 第一步：切换到你要创建项目的目录，然后使用命令创建项目</span>vue create helloworld<span class="token comment"># 第二步：选择 vue2 或者 vue3 回车，会在当前目录下创建名为 helloworld 的项目（建议vue2）</span><span class="token comment"># 第三步：进入项目目录</span><span class="token comment"># 第四步：运行项目</span><span class="token function">npm</span> run serve<span class="token comment"># 第五步：浏览器运行初始化项目,vue默认访问端口8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            2）图形化界面创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 输入回车后会自动打开vue的图形化界面</span>vue ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​            3）如果出现下载缓慢解决方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 配置淘宝镜像</span><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​            4）如果Vue 脚手架隐藏了所有 webpack 相关的配置解决方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看具体的 webpack 配置</span>vue inspect <span class="token operator">&gt;</span> output.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-模板项目的结构"><a href="#4-模板项目的结构" class="headerlink" title="4. 模板项目的结构"></a>4. 模板项目的结构</h3><p><img src="https://yzh5675.oss-cn-beijing.aliyuncs.com/blog/img/typora-user-images/image-20211025181237348.png" alt="项目结构"></p><h2 id="三、ref-与-props"><a href="#三、ref-与-props" class="headerlink" title="三、ref 与 props"></a>三、ref 与 props</h2><h3 id="1-ref"><a href="#1-ref" class="headerlink" title="1.ref"></a>1.ref</h3><p>​            1）作用：用于给节点打标识</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;!-- 定义ref --&gt;&lt;h2ref="tilte" @click="showInfo()"&gt;阿龟&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: 'App',    methods:{showInfo(){// 读取ref，取出标记的内容，获取整个被标记的标签console.log(this.$refs.tilte);}        }}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-props"><a href="#2-props" class="headerlink" title="2. props"></a>2. props</h3><pre><code>         1）作用：用于父组件给子组件传递数据（父子组件间通信）</code></pre><p>​             2）使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 父组件 --&gt;&lt;template&gt;&lt;div&gt;        &lt;!-- 数据传输 --&gt;        &lt;HelloWorld :name="name" :age="age" :adr="adr" :fn="fn"&gt;&lt;/HelloWorld&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!-- 子组件 --&gt;&lt;script&gt;export default {// 第一种定义属性方式，常用props:['age', 'adr'],// 第二种方式定义属性，常用props:{ age : Number, adr : String, name: String,fn: Function},// 第三种定义属性的方式props:{age : {type:Number, required:true, default:18},adr : {type:String, required:true, default:'湖南长沙'},name: {type:String, required:true, default:'阿龟'},fn: {type:Function, required:true, default:function fn(){console.log(465123);}}}}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、混入"><a href="#四、混入" class="headerlink" title="四、混入"></a>四、混入</h2><h3 id="1-概念-4"><a href="#1-概念-4" class="headerlink" title="1.概念"></a>1.概念</h3><p>​            将组件的选项中的一部分分离出去，单独管理</p><h3 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>​            1）全局混入（不推荐 ）</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：创建mixin.js文件，文件名可以随便取 --&gt;export const hello ={methods : {hello(){console.log("混入");}}}&lt;!-- 第二步：在main.js中引入混入的js文件 --&gt;import {hello} from './mixin.js'&lt;!-- 第三步：在main.js中使用混入 --&gt;Vue.mixin(hello)&lt;!-- 第四步：使用混入 --&gt;&lt;template&gt;&lt;div&gt;&lt;button type="button" @click="hello"&gt;混入&lt;/button&gt;&lt;!-- 混入调用的函数名 --&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {mixins:['hello'],// 混入    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        2）局部混入</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：创建mixin.js文件，文件名可以随便取 --&gt;export const hello ={methods : {hello(){console.log("混入");}}}&lt;!-- 使用混入 --&gt;&lt;template&gt;&lt;div&gt;&lt;button type="button" @click="hello"&gt;混入&lt;/button&gt;&lt;!-- 混入调用的函数名 --&gt;&lt;/div&gt;&lt;/template&gt;&lt;!-- 在需要的组件里引入minxin.js文件 --&gt;&lt;script&gt;// 引入minxing.js文件        // 使用的话和全局差不多，就是引入不同     export default {mixins:['hello'],// 混入    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、插件"><a href="#五、插件" class="headerlink" title="五、插件"></a>五、插件</h2><h3 id="1-概念-5"><a href="#1-概念-5" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            插件通常用来为 Vue 添加全局功能</p><h3 id="2-使用-2"><a href="#2-使用-2" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：创建并编写plug.js文件，文件名随便取 --&gt;export default{install (Vue, x, y, z){console.log(x, y, z);// 定义全局指令// 全局自定义指令Vue.directive('big', function(ele, bind){ele.innerText = bind.value*100;});// 定义混入Vue.mixin({data(){return{}},methods:{}});// 定义全局函数Vue.prototype.hi = ()=&gt;{alert("hello");}}}&lt;!-- 第二步：在main.js中引入并使用插件插件 --&gt;// 引入插件import plugin from './plugin.js'// 使用插件Vue.use(plugin);&lt;!-- 使用插件 --&gt;&lt;div&gt;    &lt;!-- 插件调用的函数名 --&gt;    &lt;button type="button" @click="hi"&gt;插件&lt;/button&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、自定义事件"><a href="#六、自定义事件" class="headerlink" title="六、自定义事件"></a>六、自定义事件</h2><h3 id="1-概念-6"><a href="#1-概念-6" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​            自己定义一个事件，使其完成预想的操作</p><h3 id="2-使用-3"><a href="#2-使用-3" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    export default {        // 第一步        mounted(){            // $on：创建自定义事件$once：只能触发一次的自定义事件                        // 通过ref标记一个节点来进行创建自定义事件this.$refs.school.$on('diy', data);// data可以是任何数据类型包括函数                        // 不使用ref创建自定义事件            this.$on('diy', data);// data可以是任何数据类型包括函数        }            }&lt;/script&gt;&lt;!-- 第二步：在组件中使用自定义事件 --&gt;&lt;template&gt;&lt;div&gt;&lt;button type="button" @click="diyEvent"&gt;使用自定义事件&lt;/button&gt;&lt;button type="button" @click="unbind"&gt;解绑自定义事件&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{data() {return{name : 'agui',adress : '湖南长沙'}},methods : {diyEvent(){// 使用自定义事件 ---  $emitthis.$emit('diy', this.name);},unbind(){// 解绑事件this.$off('diy');}}}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-全局事件总线"><a href="#3-全局事件总线" class="headerlink" title="3.全局事件总线"></a>3.全局事件总线</h3><p>​            1）概念：一种组件间的通信方式，适用于任意组件间通信</p><p>​            2）使用</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 第一步：在全局事件总线上定义一个函数hello --&gt;&lt;template&gt;&lt;div&gt;&lt;h2&gt;{{name}}&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{data(){return{name : "阿君"}}，mounted(){// 在全局事件总线上定义一个函数hellothis.$bus.$on("hello", (data) =&gt; {this.stuName = data;});}}&lt;/script&gt;&lt;!-- 第二步：在其他组件中使用全局事件总线 --&gt;&lt;script&gt;export default{    methods : {            sendBusValue(){// 使用事件总线this.$bus.$emit('hello', this.name);}        }    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><p>​            子向父传递数据、销毁组件代码见 <strong>customassembly项目</strong></p><h2 id="七、消息订阅及发布"><a href="#七、消息订阅及发布" class="headerlink" title="七、消息订阅及发布"></a>七、消息订阅及发布</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>​            1）这种方式的思想与全局事件总线很相似</p><p>​            2）它包含以下操作: </p><p>​                ① 订阅消息 –对应绑定事件监听</p><p>​                ② 发布消息 –分发事件</p><p>​                ③ 取消消息订阅 –解绑事件监听</p><p>​            3）实现需要引入一个消息订阅与发布的第三方实现库: PubSubJS</p><h3 id="2-使用-4"><a href="#2-使用-4" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 第一步：在对应的项目下安装PubSubJS</span><span class="token function">npm</span> <span class="token function">install</span> -S pubsub-js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;// 第二步：引入PubSubJS    import PubSub from 'pubsub-js'       // 发布订阅消息，发布之后会自动回调接收订阅的函数PubSub.publish("msgName", data);        // 接收订阅消息的回调函数    PubSub.subscribe("msgName", functon(msgName, data){ });        // 当用完消息就一定要取消消息的订阅   PubSub.unsubscribe(发布事件唯一ID);&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、Vue中的Ajax"><a href="#八、Vue中的Ajax" class="headerlink" title="八、Vue中的Ajax"></a>八、Vue中的Ajax</h2><h3 id="1-解决开发环境-Ajax-跨域问题"><a href="#1-解决开发环境-Ajax-跨域问题" class="headerlink" title="1. 解决开发环境 Ajax 跨域问题"></a>1. 解决开发环境 Ajax 跨域问题</h3><p>​            1）cors配置响应头</p><p>​                缺点：麻烦后端人员，不安全，任何人都能访问</p><p>​            2）JSONP jQuery</p><p>​            3）使用代理服务器</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;// 在项目跟目录下创建vue.config.js文件    module.exports = {pages: {index: {// 入口entry: 'src/main.js',},},lintOnSave : false,// 关闭语法检查// 开启代理服务器(一)  /**devServer: {proxy : '要代理的地址'}*/            // 开启代理服务器(二)    devServer: {proxy : {// 根据访问api的名字进行代理            '/admin' : {                target : '要代理的地址',                pathRewrite : {                    '^/admin' : ''                },                ws : true,// 是否支持websocket                changeOrigin : true// 是否控制请求头中host值            }        }} }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-VUE-项目中常用的二个-Ajax-库-—–-axios"><a href="#2-VUE-项目中常用的二个-Ajax-库-—–-axios" class="headerlink" title="2.VUE 项目中常用的二个 Ajax 库 —– axios"></a>2.VUE 项目中常用的二个 Ajax 库 —– axios</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 把axios安装在项目下</span><span class="token function">npm</span> i –save axios<span class="token comment"># 安装qs，qs作业将参数序列化成url 如；uid=cs11&amp;pwd=abc&amp;username=cs11</span><span class="token function">npm</span> <span class="token function">install</span> qs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;// 在需要的组件中导入axios    import axios from 'axios'        // 使用    export default {        methods: {            methodName01(){                // data可以不写，data：传的参数（只适用于get，post方式不适用）                axios                .get("/api/emp", data)                .then(resp =&gt; {                    // 回调函数                })                .catch(erro =&gt; {                    // 错误处理                });            },            methodName02(){// post方式                // data可以不写，data：传的参数（只适用于get，post方式不适用）                axios                .put("/api/emp", qs.stringify(data))                .then(resp =&gt; {                    // 回调函数                })                .catch(erro =&gt; {                    // 错误处理                });            }                    }    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="九、slot-插槽"><a href="#九、slot-插槽" class="headerlink" title="九、slot 插槽"></a>九、slot 插槽</h2><h3 id="1-插槽内可以是任意内容"><a href="#1-插槽内可以是任意内容" class="headerlink" title="1. 插槽内可以是任意内容"></a>1. 插槽内可以是任意内容</h3><p>​            父组件向子组件传递带数据的标签，当一个组件有不确定的结构时, 就需要使用 slot 技术，注意：插槽内容是在父组件中编译后, 再传递给子组件的</p><h3 id="2-插槽的分类及使用"><a href="#2-插槽的分类及使用" class="headerlink" title="2.插槽的分类及使用"></a>2.插槽的分类及使用</h3><p>​            1）默认插槽</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;div&gt;        &lt;!-- 定义一个插槽 --&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template&gt;&lt;!-- 使用 --&gt;&lt;组件名&gt;    插槽内容    &lt;/组件名&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        2）命名插槽</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;div&gt;        &lt;!-- 定义一个命名插槽 --&gt;        &lt;slot name="game"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template&gt;&lt;!-- 使用 --&gt;&lt;组件名&gt;        插槽内容...        &lt;a slot="game" href="#"&gt;更多游戏&lt;/a&gt;    &lt;/组件名&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        3）作用域插槽</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;&lt;div&gt;       &lt;!-- 作用域插槽 --&gt;&lt;slot :games="games"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template&gt;&lt;!-- 使用 --&gt;&lt;组件名&gt;        &lt;!-- 作用域插槽scope --&gt;        &lt;template scope="game"&gt;            &lt;ul&gt;                &lt;li&gt;dfasd&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;    &lt;/组件名&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、Vuex"><a href="#十、Vuex" class="headerlink" title="十、Vuex"></a>十、Vuex</h2><h3 id="1-概念-7"><a href="#1-概念-7" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>​                专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 VUE 应用中多 个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且 适用于任意组件间通信。</p><h3 id="2-Vuex的使用场景"><a href="#2-Vuex的使用场景" class="headerlink" title="2. Vuex的使用场景"></a>2. Vuex的使用场景</h3><p>​                1）多个组件依赖于同一状态</p><p>​                2）来自不同组件的行为需要变更同一状态</p><h3 id="3-项目下安装Vuex"><a href="#3-项目下安装Vuex" class="headerlink" title="3. 项目下安装Vuex"></a>3. 项目下安装Vuex</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">npm</span> i –save vuex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-核心概念和API"><a href="#4-核心概念和API" class="headerlink" title="4. 核心概念和API"></a>4. 核心概念和API</h3><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客订阅文章通知功能</title>
      <link href="/posts/ebb2.html"/>
      <url>/posts/ebb2.html</url>
      
        <content type="html"><![CDATA[<p>一直有小伙伴催我要我写教程，关于如何实现博客文章订阅的功能，并进行推送的功能，我接触这个也不久，百度一番，最终配置成功。手动艾特我群里的那些小伙伴，教程来了😂，</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo+GitHub Page 搭建博客</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p> 收到很多留言和联系我怎么搭建一个博客，但是由于学习比较忙，所有就没有给大家都回复到，还有很多同学想让我给搭建博客，但是我觉得授人以鱼不如授人以渔，所以整理出来一些我搭建过程中的主要步骤。在之后如果有时间或者有人想要看我是如何改的博客样式的，可以留言和评论，我再给出教程，在按照步骤搭建的过程中遇到问题也可以联系我。</p><h4 id="1-安装工具"><a href="#1-安装工具" class="headerlink" title="1.安装工具"></a>1.安装工具</h4><p>在搭建博客的前期需要安装相关的工具分别是node和git，这两个工具都可以在官网上面下载，安    装和配置可以在网上自行搜索。</p><h4 id="2-注册github账号"><a href="#2-注册github账号" class="headerlink" title="2.注册github账号"></a>2.注册github账号</h4><p>因为我们要搭建的是一个静态博客，所有要把文件都放在GitHub的仓库里，所以需要注册一个    GitHub账号以及新建一个GitHub仓库，这个比较简单可以自行搜索。</p><ul><li>这里有一个要注意的环节就是在建立仓库的时候仓库名必须是<code>用户名.github.io</code></li><li>在仓库有一个index.html文件时，在浏览器中输入<code>https://用户名.github.io</code>就可以看到index.html里的内容，github pages就创建好了（这一步只是试验，不是必须操作）</li></ul><h4 id="3-配置git用户信息"><a href="#3-配置git用户信息" class="headerlink" title="3. 配置git用户信息"></a>3. 配置git用户信息</h4><p>​    打开git输入</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name "你的github用户名"git config --global user.email "你的github邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-安装hexo静态博客框架发布到github-pages"><a href="#4-安装hexo静态博客框架发布到github-pages" class="headerlink" title="4.安装hexo静态博客框架发布到github pages"></a>4.安装hexo静态博客框架发布到github pages</h4><p>打开git输入</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-clihexo init 文件夹名cd 文件夹名npm install <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>后续操作都在上面新建的文件夹里操作</p><p>hexo框架的本地搭建完成之后就输入命令查看效果（不是必要操作）</p><pre class="line-numbers language-none"><code class="language-none">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-将本地博客发布到github-pages中"><a href="#5-将本地博客发布到github-pages中" class="headerlink" title="5.将本地博客发布到github pages中"></a>5.将本地博客发布到github pages中</h4><p>下载安装发布的插件</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将本地目录和github关联起来</p><p>生成秘钥和公钥</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C "你的github邮件地址"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一直回车，在提示目录下找到.ssh文件夹， 把公钥也就是id_rsa.pub中的内容复制到github的setting里的SSH and GPG keys中添加</li></ul><p>测试链接是否成功</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-配置站点目录并发布"><a href="#6-配置站点目录并发布" class="headerlink" title="6.配置站点目录并发布"></a>6.配置站点目录并发布</h4><p>用编辑器打开_config.yml文件，对博客进行个性化配置</p><pre class="line-numbers language-none"><code class="language-none">title: 你的博客名 subtitle: 博客的副标题，有些主题支持 description: 博客描述keywords: 博客关键词 author: 作者，在文章中显示 language: 博客语言语种 timezone: 时区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在文件的最低部添加repo项和branch项，并添加如下信息</p><pre class="line-numbers language-none"><code class="language-none">type: git repo: git@github.com:Github用户名/github用户名.github.io.git//也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后就是生成页面并且发布在github pages上，（之后写文章放在/source/_posts/目录下也上下面这三条命令上传)</p><pre class="line-numbers language-none"><code class="language-none">hexo clean    //清缓存hexo g        //渲染hexo d        //上传hexo clean &amp;&amp; hexo g -d//这是三条一起运行的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这时候打开<code>https://用户名.github.io</code>你就可以看到你的博客已经更新了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub下载慢加速</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Github-下载慢加速"><a href="#Github-下载慢加速" class="headerlink" title="Github 下载慢加速"></a>Github 下载慢加速</h2><p>解决GitHub 下载 release 资源太慢的办法</p><h3 id="1-使用下载器下载"><a href="#1-使用下载器下载" class="headerlink" title="1. 使用下载器下载"></a>1. 使用下载器下载</h3><p>  复制 release 资源链接，使用 <code>迅雷</code> 或者 <code>Free Download Manager</code> 直接下载 <a href="http://github.com/">http://github.com</a> 开头的原链接。<br>  使用迅雷下载不是很稳定，有时候速度可以秒下，有时候下载不下来。可以多试几次。 FDM暂时还没测试过。</p><p>优点： 有资源时可以下载快，从官方原链接下载，安全性可靠性相对较好</p><p>不足： 依赖下载器，需要看资源情况</p><h3 id="2-使用代下载服务l"><a href="#2-使用代下载服务l" class="headerlink" title="2. 使用代下载服务l"></a>2. 使用代下载服务l</h3><p>  复制 release 资源链接，使用github 代下载 ：</p><p>​    <a href="http://gitd.cc/">http://gitd.cc/</a><br>​    <a href="http://github.b15.me/">http://github.b15.me/</a><br>优点： 不需要下载器，随时都可以打开网站使用</p><p>不足： 网站可用性、安全性可靠性取决于代下载服务，文件会被二次压缩，且下载文件名会改变</p><h3 id="3-Github下载加速插件"><a href="#3-Github下载加速插件" class="headerlink" title="3. Github下载加速插件"></a>3. Github下载加速插件</h3><p>  安装gitHub加速插件：</p><p><a href="https://fhefh2015.github.io/Fast-GitHub/">https://fhefh2015.github.io/Fast-GitHub/</a></p><h3 id="4-使用GitHub-反代域名替换"><a href="#4-使用GitHub-反代域名替换" class="headerlink" title="4. 使用GitHub 反代域名替换"></a>4. 使用GitHub 反代域名替换</h3><p>  使用GitHub 反代域名替换</p><p><a href="https://fastgit.org/">https://fastgit.org/</a><br><a href="https://www.gitclone.com/">https://www.gitclone.com</a><br><a href="https://cdn.con.sh/">https://cdn.con.sh</a><br><a href="http://gitcdn.link/">http://gitcdn.link/</a></p><h2 id="Github-访问慢加速"><a href="#Github-访问慢加速" class="headerlink" title="Github 访问慢加速"></a>Github 访问慢加速</h2><p>内容整理来自网络。</p><h3 id="1、获取相关域名"><a href="#1、获取相关域名" class="headerlink" title="1、获取相关域名"></a>1、获取相关域名</h3><p>获取Github相关网站的域名。</p><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>访问 <a href="https://github.com/">https://github.com</a></p><p>F12 查看网络，查看域名。</p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>直接访问：<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com</a></p><h4 id="2、获取相关域名对应IP"><a href="#2、获取相关域名对应IP" class="headerlink" title="2、获取相关域名对应IP"></a>2、获取相关域名对应IP</h4><p>访问 <a href="https://www.ipaddress.com/">https://www.ipaddress.com</a></p><p>分别输入</p><p>github.global.ssl.fastly.net<br>github.com</p><p>查询ip地址</p><h3 id="3、配置hosts"><a href="#3、配置hosts" class="headerlink" title="3、配置hosts"></a>3、配置hosts</h3><p>windows 系统的 hosts 文件的位置如下：C:\Windows\System32\drivers\etc\hosts ;</p><p>mac/linux 系统的 hosts 文件的位置如下：/etc/hosts 。</p><p>下面是我的配置，更新日期 2020-09-20</p><pre class="line-numbers language-none"><code class="language-none">140.82.112.3 github.com199.232.69.194 github.global.ssl.fastly.net199.232.68.133  githubusercontent.com185.199.108.153 assets-cdn.github.com185.199.109.153 assets-cdn.github.com185.199.110.153 assets-cdn.github.com185.199.111.153 assets-cdn.github.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、刷新DNS"><a href="#4、刷新DNS" class="headerlink" title="4、刷新DNS"></a>4、刷新DNS</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig /flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应该快点了吧？</p><p>隔一段时间查一次，IP 不会一直不变，不定期更新。</p><h3 id="5、DNS命令解析IP"><a href="#5、DNS命令解析IP" class="headerlink" title="5、DNS命令解析IP"></a>5、DNS命令解析IP</h3><p>DNS查看</p><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">ipconfig /all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>底下可以看到 DNS 服务器IP相关信息。</p><p>指定DNS 解析域名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nslookup</span> github.com  <span class="token number">8.8</span>.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能显示出DNS服务器IP，说明github.com 是可以访问的，可以尝试修改自己电脑DNS再试试。</p><pre class="line-numbers language-none"><code class="language-none">谷歌：8.8.8.8阿里：223.5.5.5 或 223.6.6.6114 : 114.114.114.114百度:180.76.76.76360 : 101.226.4.5南方电信: 180.153.225.136北京联通 202.106.0.20 202.106.196.115<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig /flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
